import serial
import re
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import time
from collections import deque
import numpy as np
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import tkinter as tk

# Maximum number of points to display in the plot
MAX_POINTS = 100


class SerialPlotter:
    def __init__(self, port='COM3', baudrate=9600, timeout=1):
        # Initialize serial connection
        self.ser = serial.Serial(port, baudrate=baudrate, timeout=timeout)
        time.sleep(2)  # Allow time for Arduino to reset

        # Initialize data storage
        self.timestamps = deque(maxlen=MAX_POINTS)
        self.pomp_values = deque(maxlen=MAX_POINTS)
        self.counter_values = deque(maxlen=MAX_POINTS)
        self.counter_timestamps = deque(maxlen=MAX_POINTS)
        self.start_time = time.time()

        # Latest values
        self.latest_counter = "--"

        # Setup the main window
        self.root = tk.Tk()
        self.root.title("Real-time Monitor")
        self.root.geometry("900x700")

        # Create matplotlib figure with two subplots
        self.fig, (self.ax1, self.ax2) = plt.subplots(2, 1, figsize=(10, 8))

        # Setup the pump plot
        self.ax1.set_title("Pump Values Over Time")
        self.ax1.set_xlabel("Time (seconds)")
        self.ax1.set_ylabel("Pump Value")
        self.ax1.grid(True)
        self.line1, = self.ax1.plot([], [], 'b-', linewidth=2)

        # Setup the counter plot
        self.ax2.set_title("Counter Values Over Time")
        self.ax2.set_xlabel("Time (seconds)")
        self.ax2.set_ylabel("Counter Value")
        self.ax2.grid(True)
        self.line2, = self.ax2.plot([], [], 'r-', linewidth=2)

        # Adjust layout
        plt.tight_layout(pad=3.0)

        # Embed the matplotlib figure in tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Create a frame for displaying all values
        self.values_frame = tk.LabelFrame(self.root, text="Current Values", font=("Arial", 12, "bold"))
        self.values_frame.pack(pady=5, fill=tk.X, padx=10)

        # Create two rows in the values frame
        self.sensor_frame = tk.Frame(self.values_frame)
        self.sensor_frame.pack(fill=tk.X, pady=5)

        # Labels for sensor values
        self.pomp_label = tk.Label(self.sensor_frame, text="Pump: --", font=("Arial", 12), width=15)
        self.pomp_label.pack(side=tk.LEFT, padx=10, pady=5)

        self.height_label = tk.Label(self.sensor_frame, text="Height: --", font=("Arial", 12), width=15)
        self.height_label.pack(side=tk.LEFT, padx=10, pady=5)

        self.setpoint_label = tk.Label(self.sensor_frame, text="Setpoint: --", font=("Arial", 12), width=15)
        self.setpoint_label.pack(side=tk.LEFT, padx=10, pady=5)

        self.kp_label = tk.Label(self.sensor_frame, text="Kp: --", font=("Arial", 12), width=10)
        self.kp_label.pack(side=tk.LEFT, padx=10, pady=5)

        self.ki_label = tk.Label(self.sensor_frame, text="Ki: --", font=("Arial", 12), width=10)
        self.ki_label.pack(side=tk.LEFT, padx=10, pady=5)

        # Add counter to the sensor values
        self.counter_label = tk.Label(self.sensor_frame, text="Counter: --", font=("Arial", 12, "bold"), width=15,
                                      fg="red")
        self.counter_label.pack(side=tk.LEFT, padx=10, pady=5)

        # Raw data display
        self.raw_frame = tk.LabelFrame(self.root, text="Raw Data", font=("Arial", 12, "bold"))
        self.raw_frame.pack(pady=5, fill=tk.X, padx=10)

        self.raw_label = tk.Label(self.raw_frame, text="No data received yet", font=("Arial", 11))
        self.raw_label.pack(pady=5, padx=10)

        # Status bar
        self.status_bar = tk.Label(self.root, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

        # Setup animation
        self.ani = FuncAnimation(
            self.fig,
            self.update_plot,
            interval=100,  # Update every 100ms
            blit=False
        )

    def parse_data(self, data_string):
        """Parse the incoming data string to extract values."""
        # Create a dictionary to store the parsed values
        parsed_data = {'type': 'unknown'}

        # Check for counter message
        counter_match = re.search(r'counter: (\d+)', data_string)
        if counter_match:
            parsed_data['type'] = 'counter'
            parsed_data['counter'] = int(counter_match.group(1))
            return parsed_data

        # Check for sensor message
        height_match = re.search(r'hoogte: (\d+)', data_string)
        setpoint_match = re.search(r'setpoint: (\d+)', data_string)
        kp_match = re.search(r'kp: ([\d.]+)', data_string)
        ki_match = re.search(r'ki: ([\d.]+)', data_string)
        pomp_match = re.search(r'pomp: (\d+)', data_string)

        # Store extracted values in the dictionary
        if height_match and setpoint_match and kp_match and ki_match and pomp_match:
            parsed_data['type'] = 'sensor'
            parsed_data['hoogte'] = int(height_match.group(1))
            parsed_data['setpoint'] = int(setpoint_match.group(1))
            parsed_data['kp'] = float(kp_match.group(1))
            parsed_data['ki'] = float(ki_match.group(1))
            parsed_data['pomp'] = int(pomp_match.group(1))

        return parsed_data

    def update_plot(self, frame):
        """Update the plot with new data."""
        if self.ser.in_waiting > 0:
            # Read data from serial port
            data = self.ser.readline().decode('utf-8').strip()
            print(f"Received: {data}")

            # Update raw data display
            self.raw_label.config(text=data)

            # Parse the data
            parsed_data = self.parse_data(data)
            current_time = time.time() - self.start_time

            # Process sensor data
            if parsed_data['type'] == 'sensor':
                self.timestamps.append(current_time)
                self.pomp_values.append(parsed_data['pomp'])

                # Update the sensor value labels
                self.pomp_label.config(text=f"Pump: {parsed_data['pomp']}")
                self.height_label.config(text=f"Height: {parsed_data['hoogte']}")
                self.setpoint_label.config(text=f"Setpoint: {parsed_data['setpoint']}")
                self.kp_label.config(text=f"Kp: {parsed_data['kp']}")
                self.ki_label.config(text=f"Ki: {parsed_data['ki']}")

                # Update status
                self.status_bar.config(text=f"Last update: Sensor data at {time.strftime('%H:%M:%S')}")

                # Update the pump plot
                if len(self.timestamps) > 0:
                    self.line1.set_data(list(self.timestamps), list(self.pomp_values))

                    # Adjust the plot limits
                    self.ax1.set_xlim(
                        max(0, current_time - 30),  # Show the last 30 seconds
                        max(30, current_time + 2)
                    )

                    if len(self.pomp_values) > 0:
                        min_val = min(self.pomp_values)
                        max_val = max(self.pomp_values)
                        margin = max(1, (max_val - min_val) * 0.1)  # Add 10% margin
                        self.ax1.set_ylim(max(0, min_val - margin), max_val + margin)

            # Process counter data
            elif parsed_data['type'] == 'counter':
                self.counter_timestamps.append(current_time)
                self.counter_values.append(parsed_data['counter'])
                self.latest_counter = parsed_data['counter']

                # Update the counter value label
                self.counter_label.config(text=f"Counter: {parsed_data['counter']}")

                # Update status
                self.status_bar.config(text=f"Last update: Counter data at {time.strftime('%H:%M:%S')}")

                # Update the counter plot
                if len(self.counter_timestamps) > 0:
                    self.line2.set_data(list(self.counter_timestamps), list(self.counter_values))

                    # Adjust the plot limits
                    self.ax2.set_xlim(
                        max(0, current_time - 30),  # Show the last 30 seconds
                        max(30, current_time + 2)
                    )

                    if len(self.counter_values) > 0:
                        min_val = min(self.counter_values)
                        max_val = max(self.counter_values)
                        margin = max(1, (max_val - min_val) * 0.1)  # Add 10% margin
                        self.ax2.set_ylim(max(0, min_val - margin), max_val + margin)

        # Redraw the canvas
        self.canvas.draw()

        return self.line1, self.line2

    def run(self):
        """Start the main loop."""
        try:
            self.root.mainloop()
        finally:
            # Clean up when the application is closed
            if hasattr(self, 'ser') and self.ser.is_open:
                self.ser.close()
                print("Serial connection closed.")


if __name__ == "__main__":
    try:
        plotter = SerialPlotter(port='COM3', baudrate=9600)
        plotter.run()
    except serial.SerialException as e:
        print(f"Error opening serial port: {e}")
        print("Please check if the device is connected and the port name is correct.")
    except Exception as e:
        print(f"An error occurred: {e}")
